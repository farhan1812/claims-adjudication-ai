/*
 * generated by Xtext 2.32.0
 */
package org.farhan.mbt.validation;

import java.io.PrintWriter;
import java.io.StringWriter;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.farhan.mbt.cucumber.AbstractScenario;
import org.farhan.mbt.cucumber.Cell;
import org.farhan.mbt.cucumber.CucumberPackage;
import org.farhan.mbt.cucumber.Feature;
import org.farhan.mbt.cucumber.Step;
import org.farhan.mbt.cucumber.StepTable;
import org.farhan.helper.LanguageAccessImpl;
import org.farhan.helper.ScenarioHelper;
import org.farhan.helper.StepDefinitionHelper;
import org.farhan.helper.StepHelper;

public class CucumberValidator extends AbstractCucumberValidator {

	public static final String INVALID_NAME = "invalidName";
	public static final String INVALID_HEADER = "invalidHeader";
	public static final String INVALID_STEP_TYPE = "invalidStepType";
	public static final String MISSING_STEP_DEF = "missingStepDefinition";
	public static final String MISSING_COMPONENT = "missingInitialComponent";

	private void logError(Exception e, String name) {
		// TODO inject the logger instead
		System.out.println("There was a problem listing directories for: " + name);
		StringWriter sw = new StringWriter();
		e.printStackTrace(new PrintWriter(sw));
		System.out.println(sw.toString());
	}

	@Check(CheckType.FAST)
	public void checkStepName(Step step) {
		try {
			if (step.getName() != null) {
				// TODO the quickfix here is to identify which regex is broken and put an
				// example in place
				if (!StepHelper.isValid(step.getName())) {
					// TODO instead of this error message, give the parts breakdown to see what's
					// missing
					error(StepHelper.getErrorMessage(), CucumberPackage.Literals.STEP__NAME, INVALID_NAME);
				} else {
					String problems;

					AbstractScenario as = (AbstractScenario) step.eContainer();
					if (as.getSteps().getFirst().equals(step)) {
						problems = ScenarioHelper.validate(new LanguageAccessImpl(step));
						if (!problems.isEmpty()) {
							error(problems, CucumberPackage.Literals.STEP__NAME, MISSING_COMPONENT);
							return;
						}
					}

					problems = StepDefinitionHelper.validate(new LanguageAccessImpl(step));
					if (!problems.isEmpty()) {
						warning(problems, CucumberPackage.Literals.STEP__NAME, MISSING_STEP_DEF, step.getName());
					}
				}
			}
		} catch (Exception e) {
			logError(e, step.getName());
		}
	}

	@Check(CheckType.FAST)
	public void checkStepTableName(StepTable stepTable) {
		// TODO Add table column row validation, each row should have the max number of
		// columns
		// TODO make tests for this
		for (Cell header : stepTable.getRows().get(0).getCells()) {
			if (!Character.isUpperCase(header.getName().charAt(0))) {
				warning("Table header names should start with a capital: " + header.getName(),
						CucumberPackage.Literals.STEP_TABLE__ROWS, INVALID_HEADER, header.getName());
			}
		}
	}

	@Check(CheckType.NORMAL)
	public void checkScenario(AbstractScenario abstractScenario) {
		if (!Character.isUpperCase(abstractScenario.getName().charAt(0))) {
			warning("Scenario name should start with a capital", CucumberPackage.Literals.ABSTRACT_SCENARIO__NAME,
					INVALID_NAME);
		}
	}

	@Check(CheckType.EXPENSIVE)
	public void checkFeature(Feature feature) {
		// TODO validate that feature file name and feature name are the same.
		if (!Character.isUpperCase(feature.getName().charAt(0))) {
			warning("Feature name should start with a capital", CucumberPackage.Literals.MODEL__NAME, INVALID_NAME);
		}
	}

}
