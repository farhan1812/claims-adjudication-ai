/*
 * generated by Xtext 2.32.0
 */
package org.farhan.validation;

import java.util.HashMap;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.Path;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.builder.EclipseResourceFileSystemAccess2;
import org.eclipse.xtext.generator.OutputConfiguration;
import org.eclipse.xtext.util.RuntimeIOException;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.farhan.cucumber.Cell;
import org.farhan.cucumber.CucumberPackage;
import org.farhan.cucumber.Feature;
import org.farhan.cucumber.Scenario;
import org.farhan.cucumber.Step;
import org.farhan.cucumber.StepTable;
import org.farhan.generator.MyOutputConfigurationProvider;
import com.google.inject.Inject;
import com.google.inject.Provider;

public class CucumberValidator extends AbstractCucumberValidator {

	@Inject
	private Provider<EclipseResourceFileSystemAccess2> fileAccessProvider;

	public static final String INVALID_NAME = "invalidName";
	public static final String INVALID_HEADER = "invalidHeader";
	public static final String INVALID_STEP_TYPE = "invalidStepType";
	public static final String MISSING_STEP_DEF = "invalidStepType";

	// FAST is when the file is modified
	@Check(CheckType.FAST)
	public void checkStepName(Step step) {

		// TODO the quickfix here is to identify which regex is broken and put an
		// example in place
		if (!MBTEdgeValidator.isValid(step.getName()) && !MBTVertexValidator.isValid(step.getName())) {
			// TODO instead of this error message, give the parts breakdown to see what's
			// missing
			error(MBTVertexValidator.getErrorMessage(), CucumberPackage.Literals.STEP__NAME, INVALID_NAME);
		} else {
			// TODO if it's valid, then check if the the step def exists, if not call the
			// generator in the quick fix
			// TODO make a public get name from step in stepdefgenerator
			String fileName = getComponent(step.getName()) + "/" + getObject(step.getName()) + ".feature";
			EclipseResourceFileSystemAccess2 fsa = getFSA(step.eResource());
			// TODO instead of isFile, call some keyword search method and if it can't find
			// the keyword, it needs to give an error message explaining why like missing
			// app or missing object etc
			if (!fsa.isFile(fileName, MyOutputConfigurationProvider.DEFAULT_OUTPUT_ONCE)) {
				warning("The step def doesn't exist in " + fileName, CucumberPackage.Literals.STEP__NAME,
						MISSING_STEP_DEF, step.getName());
			}
		}
	}

	private String getComponent(String name) {
		// TODO move to StepDefGenerator
		String component = "";
		if (!StepWrapper.getComponentName(name).isBlank()) {
			component = StepWrapper.getComponentName(name) + " " + StepWrapper.getComponentType(name);
		}
		return component;
	}

	private String getObject(String name) {
		// TODO move to StepDefGenerator
		String object = StepWrapper.getObjectName(name) + " " + StepWrapper.getObjectType(name);
		return object;
	}

	private EclipseResourceFileSystemAccess2 getFSA(Resource resource) {
		EclipseResourceFileSystemAccess2 fsa = fileAccessProvider.get();

		// set the output configs
		fsa.setOutputConfigurations(MyOutputConfigurationProvider.ocpMap);

		// set the project
		fsa.setProject(ResourcesPlugin.getWorkspace().getRoot()
				.getFile(new Path(resource.getURI().toPlatformString(true))).getProject());

		return fsa;
	}

	@Check(CheckType.FAST)
	public void checkStepTableName(StepTable stepTable) {
		// TODO Add table column row validation, each row should have the max number of
		// columns
		// TODO make tests for this
		for (Cell header : stepTable.getRows().get(0).getCells()) {
			if (!Character.isUpperCase(header.getName().charAt(0))) {
				warning("Table header names should start with a capital: " + header.getName(),
						CucumberPackage.Literals.STEP_TABLE__ROWS, INVALID_HEADER, header.getName());
			}
		}
	}

	// NORMAL is when the file is saved
	@Check(CheckType.NORMAL)
	public void checkScenario(Scenario scenario) {

		// TODO validate that state and transition validation are applied to Given/Then
		// and When respectively
		// For And, But and *, the last GWT should apply. The quickfix here is to change
		// the keyword
		// TODO also check that there's a sequence of GWT or G(G|A|B)*W(W|A|B)*T(T|A|B)*
		// and not (G|W|T|A|B)*
		if (!Character.isUpperCase(scenario.getName().charAt(0))) {
			warning("Scenario name should start with a capital", CucumberPackage.Literals.ABSTRACT_SCENARIO__NAME,
					INVALID_NAME);
		}
	}

	// EXPENSIVE is when the validation menu item is selected
	@Check(CheckType.EXPENSIVE)
	public void checkFeature(Feature feature) {
		// TODO validate that feature file name and feature name are the same.
		if (!Character.isUpperCase(feature.getName().charAt(0))) {
			warning("Feature name should start with a capital", CucumberPackage.Literals.FEATURE__NAME, INVALID_NAME);
		}
	}

}
