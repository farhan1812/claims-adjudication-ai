/*
 * generated by Xtext 2.32.0
 */
package org.xtext.example.mydsl.formatting2;

import org.eclipse.xtext.formatting2.AbstractJavaFormatter;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.formatting2.ITextReplacerContext;
import org.eclipse.xtext.formatting2.internal.AbstractTextReplacer;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;
import org.eclipse.xtext.formatting2.regionaccess.ITextReplacement;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MyDslPackage.Literals;
import org.xtext.example.mydsl.myDsl.Statement;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

import com.google.inject.Inject;

public class MyDslFormatter extends AbstractJavaFormatter {

	@Inject
	private MyDslGrammarAccess ga;

	protected void format(Model model, IFormattableDocument doc) {

		// TODO move all this code below into this method.
		// Make methods for each token (keyword, assignment(feature=rulecall), rulecall)
		doc.format(model);

		// These are examples on how to access something between ''
		ISemanticRegion modelKeyword;
		// modelKeyword = regionFor(model).keyword("Feature:");
		modelKeyword = regionFor(model).keyword(ga.getModelAccess().getFeatureKeyword_0());
		doc.prepend(modelKeyword, it -> it.noSpace());
		doc.append(modelKeyword, it -> it.setSpace(" "));

		// These are examples on how to access something like name = Phrase
		// name is the feature
		// Phrase is a rule call since it references something else
		// name with Phrase altogether is an assignment.
		// All 3 reference the same region, which can be tested by triggering a
		// ConflictingFormattingException
		ISemanticRegion modelName;
		ISemanticRegion modelName1 = regionFor(model).feature(Literals.MODEL__NAME);
		ISemanticRegion modelName2 = regionFor(model).ruleCall(ga.getModelAccess().getNamePhraseParserRuleCall_1_0());
		ISemanticRegion modelName3 = regionFor(model).assignment(ga.getModelAccess().getNameAssignment_1());
		// doc.append(modelName1, it -> it.setSpace(" "));
		// I prefer the ruleCall method for now
		doc.append(modelName2, it -> it.noSpace());
		// doc.append(modelName3, it -> it.newLine());

		// These are examples on how to access something that's terminal
		ISemanticRegion modelEOL = regionFor(model).ruleCall(ga.getModelAccess().getEOLTerminalRuleCall_2());
		// This is an example of how to replace the actual text or in this case multiple
		// new lines
		doc.addReplacer(new AbstractTextReplacer(doc, modelEOL) {

			@Override
			public ITextReplacerContext createReplacements(ITextReplacerContext context) {
				// replaceWith(getRegion().getText().toUpperCase())
				context.addReplacement(getRegion().replaceWith("\r\n\r\n"));
				return context;
			}
		});

		// These are examples on how to access something with +=
		// loop through the elements and then get the name
		// the first approach is the following, loop through the elements
		for (Statement statement : model.getStatements()) {
			// regionFor statement works but not for name
			// Like you can't do model.getName() and then pass that to regionFor.
			// The reason being that name has no attributes.
			regionFor(statement);

			// TODO debug what's implementing this?
			doc.format(statement);
			// TODO This should be the same as the feature name attribute
			// and EOL terminal.
		}
		// the second is this literals business, I think you can't loop through each
		// element individually
		// modelName = regionFor(model).feature(Literals.MODEL__STATEMENTS);

		// the third is probably the same as the second, you don't go through it
		// individually

		// the fourth is to get the assignment itself but again not sure you can go
		// through it one at a time

		// My conclusion then is to just use the rule approach again to handle indenting
		// the whole area

	}

}
